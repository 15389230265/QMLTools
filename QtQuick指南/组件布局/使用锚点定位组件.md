# Positioning with Anchors



除了更传统的[网格](https://doc.qt.io/qt-5/qml-qtquick-grid.html)，[行](https://doc.qt.io/qt-5/qml-qtquick-row.html)和[列之外](https://doc.qt.io/qt-5/qml-qtquick-column.html)，Qt Quick还提供了一种使用*锚点*概念布局项目的方法。每个项目可以被认为具有一组7个不可见的“锚线”：[left](https://doc.qt.io/qt-5/qml-qtquick-item.html#anchors.left-prop)，[horizontalCenter](https://doc.qt.io/qt-5/qml-qtquick-item.html#anchors.horizontalCenter-prop)，[right](https://doc.qt.io/qt-5/qml-qtquick-item.html#anchors.right-prop)，[top](https://doc.qt.io/qt-5/qml-qtquick-item.html#anchors.top-prop)，[verticalCenter](https://doc.qt.io/qt-5/qml-qtquick-item.html#anchors.verticalCenter-prop)，[baseline](https://doc.qt.io/qt-5/qml-qtquick-item.html#anchors.baseline-prop)和[bottom](https://doc.qt.io/qt-5/qml-qtquick-item.html#anchors.bottom-prop)。

![img](使用锚点定位组件.assets/edges_qml.png)

基线（上图未显示）对应于文本所在的虚线。对于没有文字的项目，它与*顶部*相同。

Qt快速锚定系统允许您定义不同项目的锚线之间的关系。例如，你可以写：

```
Rectangle { id: rect1; ... }
Rectangle { id: rect2; anchors.left: rect1.right; ... }
```

在这种情况下，*rect2*的左边缘绑定到*rect1*的右边缘，产生以下内容：

![img](使用锚点定位组件.assets/edge1.png)

您可以指定多个锚点。例如：

```
Rectangle { id: rect1; ... }
Rectangle { id: rect2; anchors.left: rect1.right; anchors.top: rect1.bottom; ... }
```

![img](使用锚点定位组件.assets/edge3.png)

通过指定多个水平或垂直锚点，您可以控制项目的大小。下面，*rect2*锚定在*rect1*的右侧和*rect3*的左侧。如果移动了其中一个蓝色矩形，则*rect2*将根据需要拉伸和缩小：

```
Rectangle { id: rect1; x: 0; ... }
Rectangle { id: rect2; anchors.left: rect1.right; anchors.right: rect3.left; ... }
Rectangle { id: rect3; x: 150; ... }
```

![img](使用锚点定位组件.assets/edge4.png)

还有一些便利的锚点。anchors.fill是一种方便，与将目标项目的左，右，顶部和底部锚点设置为左侧，右侧，顶部和底部相同。anchors.centerIn是另一个方便的锚点，与将verticalCenter和horizontalCenter锚点设置为目标项目的verticalCenter和horizontalCenter相同。



## Anchor Margins and Offsets

锚定系统还允许为物品的锚点指定*边距*和*偏移*。边距指定留给项目锚点外部的空白空间量，而偏移量允许使用中心锚点线操纵定位。一个项目可以通过单独指定其锚利润率[LEFTMARGIN](https://doc.qt.io/qt-5/qml-qtquick-item.html#anchors.leftMargin-prop)，[rightMargin](https://doc.qt.io/qt-5/qml-qtquick-item.html#anchors.rightMargin-prop)，[TOPMARGIN](https://doc.qt.io/qt-5/qml-qtquick-item.html#anchors.topMargin-prop)和[bottomMargin](https://doc.qt.io/qt-5/qml-qtquick-item.html#anchors.bottomMargin-prop)，或使用[anchors.margins](https://doc.qt.io/qt-5/qml-qtquick-item.html#anchors.margins-prop)指定四边相同边距值。锚点偏移量使用[horizontalCenterOffset](https://doc.qt.io/qt-5/qml-qtquick-item.html#anchors.horizontalCenterOffset-prop)，[verticalCenterOffset](https://doc.qt.io/qt-5/qml-qtquick-item.html#anchors.verticalCenterOffset-prop)和[baselineOffset](https://doc.qt.io/qt-5/qml-qtquick-item.html#anchors.baselineOffset-prop)指定。

![img](使用锚点定位组件.assets/margins_qml.png)

以下示例指定左边距：

```
Rectangle { id: rect1; ... }
Rectangle { id: rect2; anchors.left: rect1.right; anchors.leftMargin: 5; ... }
```

在这种情况下，*rect2*左侧保留了5个像素的*边距*，产生以下结果：

![img](使用锚点定位组件.assets/edge2.png)

**注意：**锚点边距仅适用于锚点; 它们*不是*将边距应用于[项目](https://doc.qt.io/qt-5/qml-qtquick-item.html)的通用方法。如果为边指定了锚边距，但该项未锚定到该边上的任何项，则不应用边距。



## Changing Anchors

Qt Quick提供了[AnchorChanges](https://doc.qt.io/qt-5/qml-qtquick-anchorchanges.html)类型，用于指定状态中的锚点。

```
State {
    name: "anchorRight"
    AnchorChanges {
        target: rect2
        anchors.right: parent.right
        anchors.left: undefined  //remove the left anchor
    }
}
```

[AnchorChanges](https://doc.qt.io/qt-5/qml-qtquick-anchorchanges.html)可以使用[AnchorAnimation](https://doc.qt.io/qt-5/qml-qtquick-anchoranimation.html)类型进行动画[处理](https://doc.qt.io/qt-5/qml-qtquick-anchoranimation.html)。

```
Transition {
    AnchorAnimation {}  //animates any AnchorChanges in the corresponding state change
}
```

也可以在JavaScript中强制更改锚点。但是，应仔细订购这些更改，否则可能会产生意外结果。以下示例说明了此问题：

```
//bad code
Rectangle {
    width: 50
    anchors.left: parent.left

    function reanchorToRight() {
        anchors.right = parent.right
        anchors.left = undefined
    }
}
```

![img](使用锚点定位组件.assets/anchor_ordering_bad-1555299198817.png)

当`reanchorToRight`被调用时，函数首先设置正确的锚。此时，左侧和右侧锚点都已设置，项目将水平拉伸以填充其父级。未设置左锚点时，新宽度将保留。因此，在JavaScript中更新锚点时，首先应取消设置不再需要的锚点，然后再设置所需的任何新锚点，如下所示：

```
Rectangle {
    width: 50
    anchors.left: parent.left

    function reanchorToRight() {
        anchors.left = undefined
        anchors.right = parent.right
    }
}
```

![img](使用锚点定位组件.assets/anchor_ordering-1555299221524.png)

由于未定义绑定的评估顺序，因此不建议通过条件绑定更改锚点，因为这可能导致上述排序问题。在下面的示例中，Rectangle最终将增长到其父级的整个宽度，因为在绑定更新期间将同时设置左侧和右侧锚点。

```
//bad code
Rectangle {
    width: 50; height: 50
    anchors.left: state == "right" ? undefined : parent.left;
    anchors.right: state == "right" ? parent.right : undefined;
}
```

这应该被重写为使用[AnchorChanges](https://doc.qt.io/qt-5/qml-qtquick-anchorchanges.html)，因为[AnchorChanges](https://doc.qt.io/qt-5/qml-qtquick-anchorchanges.html)将在内部自动处理订购问题。



## Restrictions

出于性能原因，您只能将项目锚定到其兄弟姐妹和直接父母。例如，以下锚点无效并会产生警告：

```
//bad code
Item {
    id: group1
    Rectangle { id: rect1; ... }
}
Item {
    id: group2
    Rectangle { id: rect2; anchors.left: rect1.right; ... }    // invalid anchor!
}
```

此外，基于锚的布局不能与绝对定位混合。如果一个项目指定了它的[x](https://doc.qt.io/qt-5/qml-qtquick-item.html#x-prop)位置并且还设置了[anchors.left](https://doc.qt.io/qt-5/qml-qtquick-item.html#anchors.left-prop)，或者锚定了它的左右边缘但另外设置了一个[宽度](https://doc.qt.io/qt-5/qml-qtquick-item.html#width-prop)，则结果是未定义的，因为不清楚该项目是应该使用锚定还是绝对定位。使用[anchors.top](https://doc.qt.io/qt-5/qml-qtquick-item.html#anchors.top-prop)和[anchors.bottom](https://doc.qt.io/qt-5/qml-qtquick-item.html#anchors.bottom-prop)设置项目的[y](https://doc.qt.io/qt-5/qml-qtquick-item.html#y-prop)和[高度](https://doc.qt.io/qt-5/qml-qtquick-item.html#height-prop)，或者设置[anchors.fill](https://doc.qt.io/qt-5/qml-qtquick-item.html#anchors.fill-prop)以及[宽度](https://doc.qt.io/qt-5/qml-qtquick-item.html#width-prop)或[高度也是如此](https://doc.qt.io/qt-5/qml-qtquick-item.html#height-prop)。使用诸如Row和Grid之类的定位器时也是如此，它可以设置项目的[x](https://doc.qt.io/qt-5/qml-qtquick-item.html#x-prop)和[y](https://doc.qt.io/qt-5/qml-qtquick-item.html#y-prop)属性。如果您希望从使用基于锚定更改为绝对定位，可以通过将其设置为清除锚定值`undefined`。